<h2 style="color:blue">06-19</h2>

1.数字方阵

【问题描述】 

周末，爸爸妈妈带着笑笑去商场玩，正好碰上了商场在举办有奖竞答活动，而且根据问题的难度不同，奖品的价值也有不同。
其中有个问题是：在一个数字方阵中，随机放置了0~9的数字。我们把由数字1~9的组成的串称为非零串（不含0的数字串）。例如02303230，这组数据中有23和323两种非零串。其中长度最长的非零串为323。
由于这个方阵太大了，现在请你编程计算，已知一个n*m（1<=n,m<=1000）的数字方阵，求方阵第k行的最长非零串的长度。
如下图：在4*8的方阵中，第2行的最长非零串长度为3。

1	2	0	3	4	2	2	0

0	2	3	0	3	2	3	0

3	0	3	2	0	0	0	1

1	0	3	1	0	0	0	0

【输入】

输入数据有若干行。第一行，有三个整数N、M（1<=N、M<=1000）和K（1<=K<=N），其中N、M分别表示这个数字方阵中行数和列数。K表示求数字方阵第K行的最长数字串长度。
接下来有N行，每行M个0~9的数字，每个数字间用一个空格隔开。

【输出】

输出第k行的最长非零串的长度。 

【输入输出样例】

|matrix.in |	matrix.out |
| :---- | :----: |
| 4 9 3 <br>9 2 0 0 3 4 2 5 0 <br> 4 0 2 3 0 3 2 3 1 <br> 3 8 3 2 9 0 7 5 1 <br> 1 0 3 1 0 0 6 6 0 |	5

```
#include <iostream>
using namespace std;

int main()
{
	//输入
	int n, m, k;
	cin>>n>>m>>k;
	int a[500][500];
	for(int i = 0; i < n; i++){
		for (int j = 0; j < m; j++) {
			cin>>a[i][j];
		}
	}
	//取出第K行的数据到数组b 
	int b[500];
	for (int i = 0; i < m; i++) {
		b[i] = a[k - 1][i];
	}
	//验证
	cout<<"验证数组b";
	for (int i = 0; i < m; i++) {
		cout<<b[i];
	}
	cout<<endl; 
	//找最长
//	| 2 | 3 | 4 | 1 2 | 
//	0,1,2,3,4,5,6,7,8,9 
	//-> 先记录下所有0的位置
	int c[500], ci = 1;
	c[0] = 0;
	for (int i = 0; i < m; i++) {
		if (b[i] == 0) {
			c[ci] = i;
			ci++;
		}
	}
	c[ci] = m;
	//验证
	cout<<"验证数组c";
	for (int i = 0; i <= ci; i++) {
		cout<<c[i]<<", ";
	}
	cout<<endl; 
	//找距离
	int max = 0;
	for (int i = 1; i <= ci; i++) {
		int d = c[i] - c[i - 1] - 1;
		if (d > max) max = d;
	}
	cout<<max;
	return 0;
	
} 
```
